import { Collection, Db } from "npm:mongodb";
import { Empty, ID } from "@utils/types.ts";
import { freshID } from "@utils/database.ts";
import { GeminiLLM } from "@utils/gemini-llm.ts"; // Assuming this path exists and contains the GeminiLLM class

// Declare collection prefix, use concept name
const PREFIX = "ApplicationStorage" + ".";

// Generic types of this concept
type Application = ID;
type Event = ID;

/**
 * @concept ApplicationStorage [Application, Event]
 * @purpose Store application data (with applied-to event, applicant information, and answers) and AI-generated comments
 *    from that content.
 * @principle An admin can add applications to an active event. Applications include answers, and a set of comments
 *    generated by an LLM can be generated and re-generated using question and rubric sets of strings passed as parameters.
 *
 * @state
 *    a set of Applications with
 *        an event Event
 *        an applicantID String
 *        an applicantYear String
 *        an answers set of String
 *        flagged Boolean (default: false)
 *        flaggedBy User (user who flagged it)
 *        flaggedAt DateTime
 *        flagReason String
 *        disqualified Boolean (default: false)
 *        disqualificationReason String
 *        disqualifiedBy User (admin who disqualified it)
 *        disqualifiedAt DateTime
 *        undisqualifiedAt DateTime
 *        undisqualifiedBy User (admin who un-disqualified it)
 *        undisqualificationReason String
 */
interface ApplicationDoc {
  _id: Application;
  event: Event;
  applicantID: string;
  applicantYear: string;
  answers: string[];
  flagged?: boolean;
  flaggedBy?: string;
  flaggedAt?: Date;
  flagReason?: string;
  disqualified?: boolean;
  disqualificationReason?: string;
  disqualifiedBy?: string;
  disqualifiedAt?: Date;
  undisqualifiedAt?: Date;
  undisqualifiedBy?: string;
  undisqualificationReason?: string;
}

/**
 * @state
 *    a set of AIComments with
 *        an application Application
 *        a category String
 *        a quotedSnippet String
 *        a justification String
 */
interface AICommentDoc {
  _id: ID; // Each AI comment gets its own unique ID
  application: Application; // Foreign key to ApplicationDoc
  category: "Strong" | "Weak" | "Attention";
  quotedSnippet: string;
  justification: string;
}

export default class ApplicationStorageConcept {
  applications: Collection<ApplicationDoc>;
  aiComments: Collection<AICommentDoc>;
  private llm: GeminiLLM; // An instance of the LLM client

  constructor(private readonly db: Db, llmInstance?: GeminiLLM) {
    this.applications = this.db.collection(PREFIX + "applications");
    this.aiComments = this.db.collection(PREFIX + "aiComments");
    this.llm = llmInstance ?? new GeminiLLM(); // ðŸ‘ˆ use mock if provided, else real
  }

  /**
   * @action addApplication (adder: String, event: Event, applicantID: String, applicantYear: String, answers: set of String): (application: Application, event: Event)
   * @requires: applicantID and applicantYear are non-empty strings, answers is a non-empty set
   * @effects: create an application for the event for the applicantID, associated with the applicantYear
   *       and the set of answers; return the created application and event for which it was submitted
   */
  async addApplication(
    {
      adder, // The 'adder' is a string identifier; admin checks would be handled by syncs.
      event,
      applicantID,
      applicantYear,
      answers,
    }: {
      adder: string;
      event: Event;
      applicantID: string;
      applicantYear: string;
      answers: string[];
    },
  ): Promise<{ application: Application; event: Event } | { error: string }> {
    // Preconditions
    if (!applicantID || applicantID.trim() === "") {
      return { error: "Applicant ID cannot be empty." };
    }
    if (!applicantYear || applicantYear.trim() === "") {
      return { error: "Applicant Year cannot be empty." };
    }
    if (!answers || answers.length === 0) {
      return { error: "Answers cannot be empty." };
    }

    const newApplicationId = freshID();
    const newApplicationDoc: ApplicationDoc = {
      _id: newApplicationId,
      event: event,
      applicantID: applicantID,
      applicantYear: applicantYear,
      answers: answers,
      flagged: false,
      flaggedBy: undefined,
      flaggedAt: undefined,
      flagReason: undefined,
      disqualified: false,
      disqualificationReason: undefined,
      disqualifiedBy: undefined,
      disqualifiedAt: undefined,
      undisqualifiedAt: undefined,
      undisqualifiedBy: undefined,
      undisqualificationReason: undefined,
    };

    try {
      await this.applications.insertOne(newApplicationDoc);
      console.log(`Application ${newApplicationId} added for event ${event}.`);

      // Register application for assignment
      try {
        const ApplicationAssignmentsConcept = (await import("../ApplicationAssignments/ApplicationAssignmentsConcept.ts")).default;
        const applicationAssignments = new ApplicationAssignmentsConcept(this.db);
        await applicationAssignments.registerApplicationForAssignment({
          application: newApplicationId,
          event: event,
        });
      } catch (assignmentErr) {
        console.warn(`Failed to register application for assignment ${applicantID}:`, assignmentErr);
        // Don't fail the application creation for assignment registration failures
      }

      return { application: newApplicationId, event: event };
    } catch (e) {
      console.error(
        `Failed to add application for applicant ${applicantID}:`,
        e,
      );
      return { error: "Failed to add application due to database error." };
    }
  }

  /**
   * @action async generateAIComments (application: Application, questions: set of String, rubric: set of String, eligibilityCriteria: set of String)
   * @requires: application exists
   * @effects: populate AIComments or replace existing AIComments using an analysis of the answers that incorporates
   *       the provided event questions and rubric, where the category is "Strong," "Weak," or "Attention," the
   *       quotedSnippet is a substring from answers, and the justification is a non-empty string
   */
  async generateAIComments(
    {
      application,
      questions,
      rubric,
      eligibilityCriteria,
    }: {
      application: Application;
      questions: string[];
      rubric: string[];
      eligibilityCriteria: string[];
    },
  ): Promise<Empty | { error: string }> {
    // Precondition: application exists
    const existingApplication = await this.applications.findOne({
      _id: application,
    });
    if (!existingApplication) {
      return { error: `Application with ID ${application} not found.` };
    }

    const prompt = `
You are an AI model that analyzes hackathon application answers and must output STRICT JSON ONLY.

Return a JSON array of comment objects, where each object has exactly these keys:
- "category": one of ["Strong", "Weak", "Attention"]
- "quotedSnippet": a short substring (<= 2 sentences) directly from the applicant's answers
- "justification": a one-sentence explanation for the chosen category, no longer than 150 characters.

IMPORTANT RULES:
- Output ONLY a valid JSON array.
- Do NOT include Markdown formatting, code fences (\`\`\`), or any text before or after the JSON.
- The first character in your response must be '[' and the last must be ']'.
- Classify snippets aligned with desirable traits in the rubric as "Strong"
- Classify snippets showing a lack of desirable traits in the rubric as "Weak"
- Classify snippets contradicting previous information written in the application as "Attention".
- Classify snippets demonstrating disrespect or as "Attention".
- Classify snippets that contradict or may contract eligibility requirements as "Attention".

Questions:
${questions.join("\n")}

Answers:
${existingApplication.answers.join("\n")}

Eligibility Criteria:
${eligibilityCriteria.join("\n")}

Rubric:
${rubric.join("\n")}
`;

    console.log(
      `Attempting to generate AI comments for application ${application} (applicant: ${existingApplication.applicantID}).`,
    );

    let generatedComments: AICommentDoc[] = [];
    try {
      const response = await this.llm.executeLLM(prompt);

      try {
        // Parse the LLM response, allowing for `category` to be a string initially before validation
        const parsedComments: Omit<AICommentDoc, "_id" | "application">[] = JSON
          .parse(response);
        console.log(
          `Parsed LLM response for application ${application}: ${parsedComments.length} raw comment(s) found.`,
        );

        // Validation and filtering logic from previous version
        const validCategories = new Set(["Strong", "Weak", "Attention"]);
        const seenSnippets = new Set<string>();
        const filteredComments: AICommentDoc[] = [];

        for (const comment of parsedComments) {
          let isValid = true;

          // Validate category
          if (!validCategories.has(comment.category as any)) {
            console.warn(
              `Warning: Invalid category "${comment.category}" for application ${application}. Comment will be skipped.`,
            );
            isValid = false;
          }

          // Validate justification
          if (
            typeof comment.justification !== "string" ||
            comment.justification.trim() === ""
          ) {
            console.warn(
              `Warning: Empty or invalid justification in AI comment for application ${application}. Comment will be skipped.`,
            );
            isValid = false;
          } else if (comment.justification.length > 150) {
            console.warn(
              `Warning: Justification too long (>150 chars) for application ${application}. Truncating.`,
            );
            comment.justification = comment.justification.slice(0, 147) + "...";
          }

          // Validate quotedSnippet
          if (
            typeof comment.quotedSnippet !== "string" ||
            comment.quotedSnippet.trim() === ""
          ) {
            console.warn(
              `Warning: Empty or invalid quotedSnippet in AI comment for application ${application}. Comment will be skipped.`,
            );
            isValid = false;
          } else if (seenSnippets.has(comment.quotedSnippet)) {
            console.warn(
              `Warning: Duplicate quotedSnippet found for application ${application}. Duplicate comment will be skipped.`,
            );
            isValid = false;
          }

          if (isValid) {
            seenSnippets.add(comment.quotedSnippet);
            filteredComments.push({
              _id: freshID(), // Assign a fresh ID for each AI comment
              application: application, // Link to the parent application
              category: comment.category as AICommentDoc["category"], // Type assertion after validation
              quotedSnippet: comment.quotedSnippet,
              justification: comment.justification,
            });
          }
        }
        generatedComments = filteredComments;

        if (generatedComments.length === 0) {
          console.log(
            `No valid AI comments generated or parsed for application ${application}.`,
          );
        } else {
          console.log(
            `${generatedComments.length} valid AI comments processed for application ${application}.`,
          );
        }
      } catch (parseError) {
        console.error(
          `ERROR: Failed to parse AI comments JSON from LLM response for application ${application}: ${
            (parseError as Error).message
          }. Raw response: ${response}`,
        );
        return { error: "Failed to parse AI comments from LLM response." };
      }

      // Effects: populate AIComments or replace existing AIComments
      // First, delete any existing AI comments associated with this application
      await this.aiComments.deleteMany({ application: application });
      if (generatedComments.length > 0) {
        // Then, insert the newly generated and filtered comments
        await this.aiComments.insertMany(generatedComments);
        console.log(
          `Successfully stored ${generatedComments.length} AI comments for application ${application}.`,
        );
      } else {
        console.log(
          `No valid AI comments to store for application ${application}.`,
        );
      }
      return {};
    } catch (error) {
      console.error(
        `ERROR: Failed to generate AI comments for application ${application} due to LLM interaction error:`,
        error,
      );
      return { error: "Failed to generate AI comments due to LLM error." };
    }
  }

  // Example Query (not explicitly asked for, but useful for verifying effects)
  /**
   * @_getAICommentsByApplication (application: Application): (comments: set of AICommentDoc)
   * @effects: return all AI comments for a given application
   */
  async _getAICommentsByApplication(
    { application }: { application: Application },
  ): Promise<AICommentDoc[]> {
    return this.aiComments.find({ application: application }).toArray();
  }

  /**
   * @_getApplication (application: Application): (applicationDoc: ApplicationDoc)
   * @effects: return a specific application document by its ID
   */
  async _getApplication(
    { application }: { application: Application },
  ): Promise<ApplicationDoc | null> {
    return this.applications.findOne({ _id: application });
  }

  /**
   * @_getApplicationsByEvent (event: Event): Array<ApplicationDoc>
   * @effects: return all applications for a given event
   */
  async _getApplicationsByEvent(
    { event }: { event: Event },
  ): Promise<ApplicationDoc[]> {
    return this.applications.find({ event }).toArray();
  }

  /**
   * @action _bulkImportApplications (event: Event, applications: Array<{applicantID: string, applicantYear: string, answers: string[]}>, importedBy: User)
   * @requires: event exists, importedBy is admin, applications have valid data
   * @effects: create multiple applications and generate AI comments for each
   */
  async _bulkImportApplications(
    {
      event,
      applications,
      importedBy,
    }: {
      event: Event;
      applications: Array<{
        applicantID: string;
        applicantYear: string;
        answers: string[];
      }>;
      importedBy: string;
    },
  ): Promise<{
    success: true;
    importedCount: number;
    errors: Array<{ applicantID: string; error: string }>;
  } | { error: string }> {
    // 1. Validate event exists
    const eventData = await this.db.collection("EventDirectory.events").findOne({ _id: event });
    if (!eventData) {
      return { error: "Event not found" };
    }

    // 2. Validate importedBy user is admin
    const adminCheck = await this.db.collection("EventDirectory.admins").findOne({ _id: importedBy });
    if (!adminCheck) {
      return { error: "User is not admin" };
    }

    // 3. Get event questions for validation
    const questionsResult = await this.db.collection("EventDirectory.events").findOne({ _id: event });
    if (!questionsResult?.questions || questionsResult.questions.length === 0) {
      return { error: "Event has no questions configured" };
    }
    const expectedAnswersCount = questionsResult.questions.length;

    // 4. Validate applications
    const errors: Array<{ applicantID: string; error: string }> = [];
    const validApplications: Array<{
      applicantID: string;
      applicantYear: string;
      answers: string[];
    }> = [];

    // Check for duplicates within the import batch
    const batchApplicantIDs = new Set<string>();

    for (const app of applications) {
      // Check required fields
      if (!app.applicantID || app.applicantID.trim() === "") {
        errors.push({ applicantID: app.applicantID || "unknown", error: "Missing applicantID" });
        continue;
      }

      if (!app.applicantYear || app.applicantYear.trim() === "") {
        errors.push({ applicantID: app.applicantID, error: "Missing applicantYear" });
        continue;
      }

      if (!app.answers || !Array.isArray(app.answers) || app.answers.length === 0) {
        errors.push({ applicantID: app.applicantID, error: "Missing or invalid answers" });
        continue;
      }

      // Check answers length matches questions count
      if (app.answers.length !== expectedAnswersCount) {
        errors.push({
          applicantID: app.applicantID,
          error: `Answers count (${app.answers.length}) doesn't match questions count (${expectedAnswersCount})`
        });
        continue;
      }

      // Check for duplicates in batch
      if (batchApplicantIDs.has(app.applicantID)) {
        errors.push({ applicantID: app.applicantID, error: "Duplicate applicantID in import batch" });
        continue;
      }
      batchApplicantIDs.add(app.applicantID);

      // Check for existing applicantID in database
      const existing = await this.applications.findOne({ event, applicantID: app.applicantID });
      if (existing) {
        errors.push({ applicantID: app.applicantID, error: "ApplicantID already exists in this event" });
        continue;
      }

      validApplications.push(app);
    }

    // 5. If no valid applications, return success with errors
    if (validApplications.length === 0) {
      return {
        success: true,
        importedCount: 0,
        errors,
      };
    }

    // 6. Create applications and generate AI comments
    let importedCount = 0;

    for (const app of validApplications) {
      try {
        // Create the application
        const result = await this.addApplication({
          adder: importedBy,
          event,
          applicantID: app.applicantID,
          applicantYear: app.applicantYear,
          answers: app.answers,
        });

        if ("error" in result) {
          errors.push({ applicantID: app.applicantID, error: result.error });
          continue;
        }

        // Generate AI comments
        try {
          await this.generateAIComments({
            application: result.application,
            questions: questionsResult.questions,
            rubric: questionsResult.rubric || [],
            eligibilityCriteria: questionsResult.eligibilityCriteria || [],
          });
        } catch (commentErr) {
          console.warn(`Failed to generate AI comments for ${app.applicantID}:`, commentErr);
          // Don't fail the import for AI comment generation failures
        }

        // Register application for assignment
        try {
          const ApplicationAssignmentsConcept = (await import("../ApplicationAssignments/ApplicationAssignmentsConcept.ts")).default;
          const applicationAssignments = new ApplicationAssignmentsConcept(this.db);
          await applicationAssignments.registerApplicationForAssignment({
            application: result.application,
            event: event,
          });
        } catch (assignmentErr) {
          console.warn(`Failed to register application for assignment ${app.applicantID}:`, assignmentErr);
          // Don't fail the import for assignment registration failures
        }

        importedCount++;
      } catch (err) {
        errors.push({
          applicantID: app.applicantID,
          error: err instanceof Error ? err.message : "Unknown error"
        });
      }
    }

    return {
      success: true,
      importedCount,
      errors,
    };
  }

  /**
   * @query _getFlaggedApplications (event: Event)
   * @purpose: Get all flagged applications for an event (for admin dashboard)
   * @effects: Returns all flagged applications with flagging and disqualification details
   */
  async _getFlaggedApplications(
    { event }: { event: Event },
  ): Promise<Array<{
    _id: Application;
    applicantID: string;
    applicantYear: string;
    answers: string[];
    flaggedBy: string;
    flaggedAt: Date;
    flagReason: string;
    disqualified: boolean;
    disqualificationReason?: string;
    disqualifiedAt?: Date;
    disqualifiedBy?: string;
  }> | { error: string }> {
    // Validate event exists
    const eventExists = await this.db.collection("EventDirectory.events").findOne({ _id: event });
    if (!eventExists) {
      return { error: "Event not found" };
    }

    // Get all applications for this event
    const applications = await this.applications.find({ event }).toArray();
    const applicationIds = applications.map(app => app._id);

    // Get all reviews with red flags for applications in this event
    const flaggedReviews = await this.db.collection("ReviewRecords.reviews").find({
      application: { $in: applicationIds },
    }).toArray();

    // Get all red flags for these reviews
    const reviewIds = flaggedReviews.map(review => review._id);
    const redFlags = await this.db.collection("ReviewRecords.redFlags").find({
      review: { $in: reviewIds },
    }).toArray();

    // Group flags by review
    const flagsByReview = new Map<string, any[]>();
    for (const flag of redFlags) {
      if (!flagsByReview.has(flag.review.toString())) {
        flagsByReview.set(flag.review.toString(), []);
      }
      flagsByReview.get(flag.review.toString())!.push(flag);
    }

    // Create flagged applications list
    const flaggedApps: Array<{
      _id: Application;
      applicantID: string;
      applicantYear: string;
      answers: string[];
      flaggedBy: string;
      flaggedAt: Date;
      flagReason: string;
      disqualified: boolean;
      disqualificationReason?: string;
      disqualifiedAt?: Date;
      disqualifiedBy?: string;
    }> = [];

    for (const review of flaggedReviews) {
      const flags = flagsByReview.get(review._id.toString());
      if (flags && flags.length > 0) {
        const application = applications.find(app => app._id.toString() === review.application.toString());
        if (application) {
          // Use the first flag for the main flagging info
          const firstFlag = flags[0];
          flaggedApps.push({
            _id: application._id,
            applicantID: application.applicantID,
            applicantYear: application.applicantYear,
            answers: application.answers,
            flaggedBy: firstFlag.author,
            flaggedAt: review.submittedAt, // Use review submission time as flagging time
            flagReason: "Flagged by reader", // Default reason since flags don't store reasons
            disqualified: application.disqualified || false,
            disqualificationReason: application.disqualificationReason,
            disqualifiedAt: application.disqualifiedAt,
            disqualifiedBy: application.disqualifiedBy,
          });
        }
      }
    }

    // Sort by flaggedAt (newest first)
    flaggedApps.sort((a, b) => {
      const aTime = a.flaggedAt instanceof Date ? a.flaggedAt.getTime() : new Date(a.flaggedAt).getTime();
      const bTime = b.flaggedAt instanceof Date ? b.flaggedAt.getTime() : new Date(b.flaggedAt).getTime();
      return bTime - aTime;
    });

    return flaggedApps;
  }

  /**
   * @action _disqualifyApplication (application: Application, reason: String, disqualifiedBy: User, disqualifiedAt: DateTime)
   * @purpose: Officially disqualify a flagged application (admin action)
   * @requires: Application exists and is flagged, disqualifiedBy user is admin, reason is non-empty
   * @effects: Set disqualification details on the application
   */
  async _disqualifyApplication(
    {
      application,
      reason,
      disqualifiedBy,
      disqualifiedAt,
    }: {
      application: Application;
      reason: string;
      disqualifiedBy: string;
      disqualifiedAt: Date;
    },
  ): Promise<{ success: true } | { error: string }> {
    // Validate application exists and has flags
    const app = await this.applications.findOne({ _id: application });
    if (!app) {
      return { error: "Application not found" };
    }

    // Check if application has flags in ReviewRecords
    const reviews = await this.db.collection("ReviewRecords.reviews").find({
      application: application,
    }).toArray();

    const reviewIds = reviews.map(review => review._id);
    const redFlags = await this.db.collection("ReviewRecords.redFlags").find({
      review: { $in: reviewIds },
    }).toArray();

    if (redFlags.length === 0) {
      return { error: "Application is not flagged" };
    }

    // Validate admin user
    const adminCheck = await this.db.collection("EventDirectory.admins").findOne({ _id: disqualifiedBy });
    if (!adminCheck) {
      return { error: "User is not admin" };
    }

    // Validate reason
    if (!reason || reason.trim().length === 0) {
      return { error: "Disqualification reason is required" };
    }

    // Update application
    await this.applications.updateOne(
      { _id: application },
      {
        $set: {
          disqualified: true,
          disqualificationReason: reason.trim(),
          disqualifiedBy: disqualifiedBy,
          disqualifiedAt: disqualifiedAt,
        },
      },
    );

    return { success: true };
  }

  /**
   * @action _removeFlag (application: Application, removedBy: User, removedAt: DateTime)
   * @purpose: Remove flag from an application (admin action)
   * @requires: Application exists and is flagged, removedBy user is admin
   * @effects: Remove flag but keep disqualification status if already disqualified
   */
  async _removeFlag(
    {
      application,
      removedBy,
      removedAt,
    }: {
      application: Application;
      removedBy: string;
      removedAt: Date;
    },
  ): Promise<{ success: true } | { error: string }> {
    // Validate application exists and has flags
    const app = await this.applications.findOne({ _id: application });
    if (!app) {
      return { error: "Application not found" };
    }

    // Check if application has flags in ReviewRecords
    const reviews = await this.db.collection("ReviewRecords.reviews").find({
      application: application,
    }).toArray();

    const reviewIds = reviews.map(review => review._id);
    const redFlags = await this.db.collection("ReviewRecords.redFlags").find({
      review: { $in: reviewIds },
    }).toArray();

    if (redFlags.length === 0) {
      return { error: "Application is not flagged" };
    }

    // Validate admin user
    const adminCheck = await this.db.collection("EventDirectory.admins").findOne({ _id: removedBy });
    if (!adminCheck) {
      return { error: "User is not admin" };
    }

    // Remove all flags from ReviewRecords for this application
    await this.db.collection("ReviewRecords.redFlags").deleteMany({
      review: { $in: reviewIds },
    });

    return { success: true };
  }

  /**
   * @action _undisqualifyApplication (application: Application, undisqualifiedBy: User, reason: String)
   * @purpose: Remove disqualification status from an application (admin action)
   * @requires: Application exists and is disqualified, undisqualifiedBy user is admin
   * @effects: Remove disqualification status and log the un-disqualification action
   */
  async _undisqualifyApplication(
    {
      application,
      undisqualifiedBy,
      reason,
    }: {
      application: Application;
      undisqualifiedBy: string;
      reason?: string;
    },
  ): Promise<{ success: true; message: string } | { error: string }> {
    // Validate application exists and is disqualified
    const app = await this.applications.findOne({ _id: application });
    if (!app) {
      return { error: "Application not found" };
    }

    if (!app.disqualified) {
      return { error: "Application is not currently disqualified" };
    }

    // Validate admin user
    const adminCheck = await this.db.collection("EventDirectory.admins").findOne({ _id: undisqualifiedBy });
    if (!adminCheck) {
      return { error: "Admin authorization required" };
    }

    // Update application to remove disqualification and log un-disqualification
    await this.applications.updateOne(
      { _id: application },
      {
        $set: {
          disqualified: false,
          disqualificationReason: undefined,
          disqualifiedAt: undefined,
          disqualifiedBy: undefined,
          undisqualifiedAt: new Date(),
          undisqualifiedBy: undisqualifiedBy,
          undisqualificationReason: reason || "Un-disqualified by admin",
        },
      },
    );

    return {
      success: true,
      message: "Application un-disqualified successfully"
    };
  }

  /**
   * @query _getDisqualifiedApplications (event: Event)
   * @purpose: Get all disqualified applications for CSV export
   * @effects: Returns all disqualified applications with disqualification details
   */
  async _getDisqualifiedApplications(
    { event }: { event: Event },
  ): Promise<Array<{
    _id: Application;
    applicantID: string;
    disqualificationReason: string;
    disqualifiedAt: Date;
    disqualifiedBy: string;
  }> | { error: string }> {
    // Validate event exists
    const eventExists = await this.db.collection("EventDirectory.events").findOne({ _id: event });
    if (!eventExists) {
      return { error: "Event not found" };
    }

    // Get all disqualified applications for this event
    const disqualifiedApps = await this.applications.find({
      event: event,
      disqualified: true,
    }).sort({ disqualifiedAt: -1 }).toArray();

    // Return only the fields needed for CSV export
    return disqualifiedApps.map(app => ({
      _id: app._id,
      applicantID: app.applicantID,
      disqualificationReason: app.disqualificationReason!,
      disqualifiedAt: app.disqualifiedAt!,
      disqualifiedBy: app.disqualifiedBy!,
    }));
  }
}
